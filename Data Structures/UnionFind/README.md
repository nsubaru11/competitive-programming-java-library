# Union-Find (Disjoint-Set)

## 概要

Union-Find（または素集合データ構造）は、素集合を効率的に管理するためのデータ構造です。主に、要素のグループ化、グループ間の結合、要素が同じグループに属するかの判定などの操作を高速に実行できます。このライブラリでは、パス圧縮とランク付けによる最適化を施したUnion-Findの実装を提供しています。

## 実装クラス

### [UnionFind](./src/UnionFind.java)

- **用途**：素集合を効率的に管理し、要素のグループ化と検索を行うためのデータ構造
- **特徴**：
	- パス圧縮による`find`操作の最適化
	- ランク付けによる`union`操作の最適化
	- 各グループのサイズ（要素数）の追跡
	- 各グループの辺数（パス数）の追跡
	- 全グループの列挙機能
- **主な操作**:
	- `find(int n)`: 要素nの代表元（ルート）を取得
	- `isConnected(int x, int y)`: 要素xとyが同じグループに属するかを判定
	- `union(int x, int y)`: 要素xとyが属するグループを結合
	- `groupCount()`: 現在のグループ数を取得
	- `size(int x)`: 要素xが属するグループのサイズを取得
	- `pathCount(int x)`: 要素xが属するグループの辺数を取得
	- `groups()`: 全てのグループを取得
- **時間計算量**：
	- 初期化: O(n)
	- find操作: 償却O(α(n))、ここでα(n)はアッカーマン関数の逆関数（実用上はほぼO(1)）
	- union操作: 償却O(α(n))
	- isConnected操作: 償却O(α(n))
	- groupCount/size/pathCount操作: O(α(n))
	- groups操作: O(n)
- **空間計算量**：O(n)、ここでnは要素数

## アルゴリズム（データ構造）選択ガイド

Union-Findは以下のような問題に特に適しています：

- 要素のグループ化と、要素が同じグループに属するかの判定が必要な場合
- グラフの連結成分を管理する場合
- クラスカル法による最小全域木の計算
- 動的な連結性の判定
- 等価関係の管理

以下のような場合は、他のデータ構造を検討すべきです：

- グループからの要素の削除が必要な場合（Union-Findは基本的に削除をサポートしていない）
- グループ内の全要素の列挙が頻繁に必要な場合（`groups()`メソッドはO(n)の時間がかかる）
- 複雑なグラフ探索が必要な場合（深さ優先探索や幅優先探索を検討）

## 注意事項

- Union-Findは基本的に「結合」操作のみをサポートし、「分割」操作はサポートしていません。
- パス圧縮とランク付けの最適化により、ほぼ定数時間での操作が可能ですが、理論的な最悪時間計算量はO(log n)です。
- 要素は0からn-1までの整数で表現されるため、他の型の要素を使用する場合は、整数へのマッピングが必要です。
- `pathCount`メソッドは、グループ内の辺の数を追跡します。これは、グループ内の要素数が1つの場合は0、それ以外の場合は（要素数 -
	1）以上になります。
- `groups()`メソッドは全てのグループを取得するためにO(n)の時間がかかるため、頻繁に呼び出す場合は注意が必要です。