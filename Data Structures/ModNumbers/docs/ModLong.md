# ModLong 利用ガイド

## 概要

ModLong は、long 型の値に対して剰余演算（modulo 演算）を効率的に行うためのイミュータブルなラッパークラスです。
ModInt では扱えない大きな mod 値（int 範囲を超える素数）を使用する競技プログラミング問題向けに設計されています。

## 特徴

- イミュータブル（不変）設計で安全性を確保
- int 範囲（約2×10^9）を超える大きな mod 値に対応
- フェルマーの小定理を利用した除算（逆元計算）
- 繰り返し二乗法による高速なべき乗計算
- 2による除算を事前計算により O(1) で実行
- final クラスで継承を禁止し、意図しない拡張を防止

## 依存関係

Java 標準ライブラリのみを使用（外部ライブラリ不要）

## 主な機能（メソッド一覧）

### 1. コンストラクタ系メソッド

| メソッド                            | 戻り値の型 | 説明                              |
|---------------------------------|-------|---------------------------------|
| `ModLong(long value, long mod)` | -     | 値と mod を指定して初期化。inv2（2の逆元）を事前計算 |

### 2. 算術演算系メソッド

| メソッド                 | 戻り値の型   | 説明                                                     |
|----------------------|---------|--------------------------------------------------------|
| `add(ModLong other)` | ModLong | モジュロ加算を実行。(this + other) % mod を返す                     |
| `sub(ModLong other)` | ModLong | モジュロ減算を実行。(this - other + mod) % mod を返す               |
| `mul(ModLong other)` | ModLong | モジュロ乗算を実行。(this * other) % mod を返す                     |
| `div(ModLong other)` | ModLong | モジュロ除算を実行。this * other^(-1) % mod を返す。除数が2の場合は最適化経路を使用 |
| `pow(int exp)`       | ModLong | モジュロべき乗を実行。this^exp % mod を返す                          |

### 3. アクセサ系メソッド

| メソッド         | 戻り値の型  | 説明              |
|--------------|--------|-----------------|
| `value()`    | long   | 内部に保持している値を取得   |
| `mod()`      | long   | 使用している mod 値を取得 |
| `toString()` | String | 内部値を文字列表現で返す    |

### 4. 内部ヘルパーメソッド

| メソッド                     | 戻り値の型 | 説明                           |
|--------------------------|-------|------------------------------|
| `modPow(long n, long k)` | long  | 繰り返し二乗法によるべき乗計算。private メソッド |

## 利用例

```java
// 大きな mod 値での使用例
long MOD = 1000000000000000003L;  // 10^18 + 3（素数）

ModLong a = new ModLong(5000000000000000000L, MOD);
ModLong b = new ModLong(3000000000000000000L, MOD);

// 加算
ModLong sum = a.add(b);
System.out.println(sum);

// 減算
ModLong diff = a.sub(b);
System.out.println(diff);

// 乗算
ModLong prod = a.mul(b);
System.out.println(prod);

// 除算（逆元を使用）
long mod2 = 1000000007L;
ModLong x = new ModLong(10, mod2);
ModLong y = new ModLong(3, mod2);
ModLong quotient = x.div(y);  // 10 * 3^(-1) % mod
System.out.println(quotient);

// 2による除算は最適化される
ModLong half = x.div(new ModLong(2, mod2));
System.out.println(half);  // 5

// べき乗計算
ModLong base = new ModLong(2, mod2);
ModLong power = base.pow(63);  // 2^63 % mod
System.out.println(power);

// 値とmodの取得
System.out.println("value: " + power.value());
System.out.println("mod: " + power.mod());
```

## 注意事項

- mod 値は素数である必要があります。除算操作はフェルマーの小定理（a^(p-1) ≡ 1 (mod p)）を利用しているためです
- 演算を行う2つの ModLong オブジェクトは同じ mod 値を持つことを前提としています。異なる mod 間の演算は想定されておらず、チェックも行われません
- 負数をコンストラクタに渡した場合、そのまま内部に格納されます。演算時に mod による正規化が行われますが、value()
	で取得する値は負の可能性があります
- イミュータブル設計のため、全ての演算は新しい ModLong オブジェクトを返します。元のオブジェクトは変更されません
- ModInt と異なり、デフォルトコンストラクタは提供されていません。必ず value と mod を明示的に指定する必要があります
- mod が約3×10^9を超える場合、理論上は乗算時にオーバーフローのリスクがありますが、競技プログラミングで一般的な mod
	値（10^9+7、998244353など）では問題ありません
- 2による除算は頻繁に使用されるため、コンストラクタで2の逆元を事前計算して最適化しています

## パフォーマンス特性

- **加算・減算・乗算の時間計算量**: O(1)
- **除算の時間計算量**:
	- 除数が2の場合: O(1)（事前計算済み逆元を使用）
	- 一般の場合: O(log mod)（フェルマーの小定理による逆元計算）
- **べき乗の時間計算量**: O(log exp)（繰り返し二乗法）
- **空間計算量**: O(1)（インスタンスあたり固定サイズ）

## バージョン情報

| バージョン番号       | 年月日        | 詳細                              |
|:--------------|:-----------|:--------------------------------|
| **バージョン 1.0** | 2025-10-13 | 初版リリース。基本的な算術演算、除算（逆元）、べき乗をサポート |

### バージョン管理について

バージョン番号は2桁で管理します：

- 1桁目（メジャーバージョン）: メソッドの追加や機能拡張があった場合に更新
- 2桁目（マイナーバージョン）: 誤字修正、バグ修正、マイクロ高速化などの小さな更新があった場合に更新