# Modular Numbers

## 概要

剰余演算を効率的に行うためのイミュータブルなラッパークラス群を提供します。
ModInt（int 型対応）と ModLong（long 型対応）の2つのクラスがあり、競技プログラミングで頻出する mod 計算を簡潔に記述できます。

## 実装クラス

### [ModInt](src/ModInt.java)

- **用途**: int 範囲の mod 値を扱う剰余演算クラス
- **特徴**:
	- デフォルト mod 値: 998244353（FFT フレンドリー素数）
	- 2による除算を O(1) で実行（事前計算による最適化）
	- 全ての演算で新しいインスタンスを返すイミュータブル設計
	- フェルマーの小定理による除算（逆元計算）
	- 繰り返し二乗法による高速なべき乗計算
- **時間計算量**:
	- 加算/減算/乗算: O(1)
	- 除算（除数=2）: O(1)
	- 除算（一般）: O(log mod)
	- べき乗: O(log exp)
- **空間計算量**: O(1)

### [ModLong](src/ModLong.java)

- **用途**: long 範囲の mod 値を扱う剰余演算クラス
- **特徴**:
	- int 範囲を超える大きな mod 値に対応（最大 約9×10^18）
	- 2による除算を O(1) で実行（事前計算による最適化）
	- 全ての演算で新しいインスタンスを返すイミュータブル設計
	- フェルマーの小定理による除算（逆元計算）
	- 繰り返し二乗法による高速なべき乗計算
- **時間計算量**:
	- 加算/減算/乗算: O(1)
	- 除算（除数=2）: O(1)
	- 除算（一般）: O(log mod)
	- べき乗: O(log exp)
- **空間計算量**: O(1)

## アルゴリズム（データ構造）選択ガイド

### ModInt を選択すべき場合

mod 値が int 範囲内（約2×10^9以下）の場合は ModInt を使用してください。特に以下のような状況で推奨されます：

- 一般的な競技プログラミングの mod 値を使用する場合（998244353、1000000007など）
- デフォルト mod で十分な場合（コンストラクタ記述を簡略化できる）
- パフォーマンスを最優先する場合（long 演算より高速）

### ModLong を選択すべき場合

mod 値が int 範囲を超える場合や、値自体が long 範囲の大きな数である場合は ModLong を使用してください：

- mod 値が 2×10^9 を超える素数の場合
- 10^18 オーダーの大きな素数を mod として使用する必要がある場合
- 値が long 範囲でないと表現できない場合

## 注意事項

- mod 値は素数である必要があります（除算操作でフェルマーの小定理を使用するため）
- 演算を行う2つのオブジェクトは同じ mod 値を持つことを前提としています
- 負数をコンストラクタに渡した場合、そのまま格納されます。演算時に自動で正規化されますが、value() で取得する値は負の可能性があります
- イミュータブル設計のため、演算結果は常に新しいオブジェクトとして返されます