# Trie木とは

## はじめに

Trie（トライ）木とは、文字列を効率よく保存・検索するための木構造のデータ構造の一つです。  
接頭辞（prefix）を基にノードを共有することで、重複する部分を効率的に管理できます。  
この仕組みにより、長さ **M** の文字列を接頭辞とする単語の個数の検索や、  
特定の単語の存在判定を **O(M)** の時間で実行できるため、大量の単語を扱う場面で有用です。

## Trie木の基本構造

Trie木は、以下のような特徴を持ちます。

1. **各ノードは1つの文字を持つ**
	- ルートノードは空の文字列を表し、そこから各単語の接頭辞に対応するノードが連なる。

2. **共通する接頭辞は同じ経路をたどる**
	- 例えば、"cat" と "car" は `ca` まで同じノードを共有し、その後別のノードへ分岐する。

3. **単語の終端を示すフラグを持つ**
	- 各ノードには、そこが単語の終端であるかどうかを示すフラグ（bool値）を持たせる。

### 図解（例）

以下の単語 `"cat", "car", "cap", "dog"` をTrie木に格納すると、以下のような構造になります。

```
(root)
 ├── c
 │   ├── a
 │   │   ├── t (終端)
 │   │   ├── r (終端)
 │   │   ├── p (終端)
 │
 ├── d
     ├── o
         ├── g (終端)
```

この構造のおかげで、"ca" で始まる単語の検索が高速に行えます。

---

## Trie木の基本操作

### 1. **単語の挿入（Insert）**

新しい単語をTrie木に追加するには、次の手順を行います。

- ルートノードから開始し、単語の各文字ごとにノードをたどる。
- その文字に対応するノードがなければ、新しくノードを作成する。
- 単語の最後の文字のノードに「終端フラグ」を設定する。

**例:** `"car"` を追加する場合

```
(root) → c → a → r (終端)
```

### 2. **単語の検索（Find）**

Trie木内に指定した単語が存在するか判定するには、次の手順を行います。

- ルートから開始し、単語の各文字を順番にたどる。
- もし途中で存在しないノードがあれば、その単語はTrie木に含まれない。
- すべての文字をたどった後、最後のノードに「終端フラグ」が設定されていれば、その単語は存在する。

**例:** `"cat"` の検索

```
(root) → c → a → t (終端) → true
```

一方で `"cap"` を検索した場合、もし `"cap"` が登録されていなければ `false` となる。

### 3. **接頭辞の検索（Prefix Search）**

特定の接頭辞（prefix）で始まる単語が存在するか、またはいくつあるかを調べる場合は、

- ルートノードから接頭辞の最後の文字までたどる。
- そのノード以下にどれだけの単語が登録されているかカウントする。

この操作はオートコンプリート機能の実装などに役立つ。

**例:** `"ca"` の接頭辞検索

```
(root) → c → a  
        ├── t (終端)
        ├── r (終端)
        ├── p (終端)
```

結果: `3個の単語が "ca" で始まる`

---

## Trie木の派生アルゴリズムと関連データ構造

Trie木は、基本的な形からさまざまな派生アルゴリズムやデータ構造が考案されており、それぞれ異なる用途に適しています。  
ここでは、代表的なものを紹介します。

---

### 1. **圧縮Trie（Compressed Trie, Patricia Trie）**

**概要:**  
通常のTrie木では、各ノードが1文字ずつ格納されますが、圧縮Trieでは **単一のノードに複数の文字を格納** できるようにします。  
これにより、ノード数を削減し、メモリ使用量を抑えられます。

**特徴:**

- **長い接頭辞を一つのノードにまとめる** ことで、通常のTrieに比べてノード数が減る。
- 検索や挿入の平均時間計算量は **O(M)** （Mはクエリ文字列の長さ）。
- メモリ効率が向上するが、圧縮操作の実装がやや複雑になる。

**用途:**

- ルーティングテーブル（IPアドレス検索など）
- 辞書データ圧縮
- 文字列の効率的な管理

---

### 2. **動的Trie（Dynamic Trie）**

**概要:**  
通常のTrie木は静的なデータを格納するのに向いていますが、**動的Trie** は文字列の追加・削除をより柔軟に行えるようにしたものです。

**特徴:**

- ノードの追加・削除が可能（通常のTrieは削除操作が難しい場合がある）。
- メモリ効率を考慮し、不要なノードを適切に削除する仕組みが求められる。
- 動的環境でのオートコンプリートやテキストエディタの補完機能に適している。

**用途:**

- オンライン辞書（リアルタイムで単語を追加・削除）
- インクリメンタル検索（リアルタイムの検索補助）

---

### 3. **Ternary Search Tree（TST, 三分探索木）**

**概要:**  
Trie木の代替として、各ノードに3つの子ノード（左・中央・右）を持つデータ構造。  
文字を **二分探索木の要領で管理** するため、メモリ使用量を削減できる。

**特徴:**

- ノード数が **O(N)**（Nは格納する単語の総数）で済むため、通常のTrie木よりもメモリ効率が良い。
- 検索の時間計算量は **O(M + log N)**（Mはクエリの長さ、Nは格納単語数）。
- Trie木と比較すると、ノードの作成コストが高いため、大量のデータに向かない場合がある。

**用途:**

- メモリ制約のある環境での辞書管理
- 文字列の高速検索と圧縮が必要な場面

---

### 4. **Radix Trie（Radix Tree, Prefix Tree）**

**概要:**  
圧縮Trieの一種で、**複数の文字を1つのノードにまとめる** ことで、Trie木のサイズを小さくする。  
特に、キーが少なくノード数が増えがちな場合に有効。

**特徴:**

- 1ノードに複数の文字列を保持し、メモリ使用量を削減。
- IPルーティングやデータ圧縮で活用される。
- 検索や挿入の計算量は **O(M)**。

**用途:**

- ネットワークルーティング（IPアドレス管理）
- 辞書の圧縮

---

### 5. **Suffix Trie（接尾辞Trie）**

**概要:**  
文字列の**すべての接尾辞（suffix）をTrieに格納** するデータ構造。  
通常のTrieとは異なり、**部分文字列検索** に特化している。

**特徴:**

- O(N²) のノードを作成するため、通常のTrieよりもメモリ消費が大きい。
- 文字列の検索（パターンマッチング）を **O(M)** で実行可能。
- 後述する「Suffix Tree（接尾辞木）」の簡易版ともいえる。

**用途:**

- 文字列のパターンマッチング（検索エンジン、DNA解析など）
- 文書検索

---

### 6. **Suffix Tree（接尾辞木, Ukkonen’s Algorithm）**

**概要:**  
Suffix Trie をさらに圧縮し、**O(N) のメモリで構築可能なデータ構造**。  
Ukkonenのアルゴリズムにより **O(N)** で構築できる。

**特徴:**

- 文字列の任意の部分の検索が **O(M)** で可能。
- メモリ効率は Suffix Trie よりも優れるが、実装が複雑。
- Suffix Array に比べると、構築時間が高速（ただし実装難易度は高め）。

**用途:**

- 文章検索
- DNA解析（ゲノムデータのパターンマッチング）
- 重複文字列の検出

---

### 7. **Suffix Array（接尾辞配列）**

**概要:**  
Suffix Tree の代替として考案されたデータ構造で、**すべての接尾辞を辞書順に並べた配列**。

**特徴:**

- O(N log N) の時間で構築可能（効率の良い手法を使えば O(N) も可能）。
- Suffix Tree に比べてメモリ効率が良いが、検索には **O(M log N)** の時間がかかる。
- Burrows-Wheeler Transform（BWT）と組み合わせることで、圧縮アルゴリズムにも応用される。

**用途:**

- テキスト検索（全文検索エンジン）
- 圧縮アルゴリズム（BWT, FM-Index）
- 遺伝子配列解析

---

## まとめ

| データ構造                   | 特徴                | 用途           | 計算量          |
|-------------------------|-------------------|--------------|--------------|
| **Trie木**               | 文字ごとにノードを持つ基本構造   | オートコンプリート、辞書 | O(M)         |
| **圧縮Trie**              | ノードを圧縮してメモリ削減     | ルーティング、圧縮辞書  | O(M)         |
| **Ternary Search Tree** | 二分探索木の形状を持つ       | メモリ制約のある環境   | O(M + log N) |
| **Radix Tree**          | Prefixに基づいてノードを圧縮 | ネットワークルーティング | O(M)         |
| **Suffix Trie**         | すべての接尾辞を保持        | 部分文字列検索      | O(N²)        |
| **Suffix Tree**         | 圧縮版の Suffix Trie  | DNA解析、テキスト検索 | O(N)         |
| **Suffix Array**        | 配列ベースの検索構造        | 圧縮、全文検索      | O(N log N)   |

Trie木の派生データ構造は、それぞれ異なる目的に特化して設計されており、用途に応じた適切な選択が重要です。
