# トライ木 (Trie)

## 概要

トライ木（接頭辞木）は、文字列の集合を効率的に格納し検索するためのデータ構造です。特に、文字列の前方一致検索や、共通接頭辞を持つ文字列の検索に優れています。このライブラリでは、基本的なトライ木の実装と、将来的に実装予定の様々なトライ木の変種（コンパクトトライ、ダブル配列トライなど）を提供しています。

## 実装クラス

### [Trie](./src/Trie.java)

- **用途**：文字列の集合を効率的に格納し検索するための基本的なトライ木
- **特徴**：
	- 文字列の挿入、検索、前方一致検索をサポート
	- 各ノードで文字列の出現頻度を追跡
	- HashMap を使用した子ノードの管理
- **主な操作**:
	- `insert(String word)`: 単語をトライに挿入
	- `search(String word)`: 単語がトライに存在するかを検索
	- `countPrefix(String prefix)`: 指定した接頭辞で始まる単語の出現回数を取得
- **時間計算量**：
	- 挿入: O(m)、ここでmは文字列の長さ
	- 検索: O(m)
	- 前方一致検索: O(m)
- **空間計算量**：O(n * m)、ここでnは単語の数、mは平均文字列長

### [CompactTrie](./src/CompactTrie.java) (計画中)

- **用途**：メモリ使用量を削減した圧縮トライ木
- **特徴**：
	- 単一の子を持つノードを圧縮してメモリ使用量を削減
	- 基本的なトライと同等の機能を提供しつつ、空間効率が向上
- **時間計算量**：
	- 挿入: O(m)
	- 検索: O(m)
- **空間計算量**：O(n)、ここでnは単語の総文字数

### [RadixTrie](./src/RadixTrie.java) (計画中)

- **用途**：パスを圧縮したラディックストライ（基数木）
- **特徴**：
	- エッジに単一の文字ではなく文字列を格納
	- 共通接頭辞を持つ単語を効率的に格納
- **時間計算量**：
	- 挿入: O(m)
	- 検索: O(m)
- **空間計算量**：O(n)、ここでnは単語の総文字数

### [PatriciaTrie](./src/PatriciaTrie.java) (計画中)

- **用途**：ビット単位の比較を行うPATRICIAトライ
- **特徴**：
	- ビットレベルでの比較による高速な検索
	- 特に長い共通接頭辞を持つデータセットに効率的
- **時間計算量**：
	- 挿入/検索: O(m)、ここでmはビット長
- **空間計算量**：O(n)、ここでnはキーの総ビット数

### [TernarySearchTree](./src/TernarySearchTree.java) (計画中)

- **用途**：3分探索木による文字列の格納と検索
- **特徴**：
	- 各ノードが3つの子（左、中、右）を持つ
	- トライよりもメモリ効率が良く、ハッシュテーブルよりも柔軟な検索が可能
- **時間計算量**：
	- 挿入/検索: O(m log n)、ここでmは文字列の長さ、nは文字の種類数
- **空間計算量**：O(n)、ここでnは単語の総文字数

### [DoubleArrayTrie](./src/DoubleArrayTrie.java) (計画中)

- **用途**：高速な検索と省メモリを両立するダブル配列トライ
- **特徴**：
	- 2つの配列（base, check）を使用した効率的な実装
	- 非常に高速な検索と省メモリを両立
	- 特に静的なデータセットに適している
- **時間計算量**：
	- 検索: O(m)
	- 構築: O(n * m)
- **空間計算量**：O(n)、ここでnはノード数

### [SuffixTree](./src/SuffixTree.java) (計画中)

- **用途**：文字列の全ての接尾辞を格納する接尾辞木
- **特徴**：
	- 部分文字列検索、最長共通部分文字列などの複雑な文字列操作に対応
	- 文字列パターンマッチングに強力
- **時間計算量**：
	- 構築: O(m)
	- 検索: O(p)、ここでpは検索パターンの長さ
- **空間計算量**：O(m)、ここでmは文字列の長さ

### [SuffixArray](./src/SuffixArray.java) (計画中)

- **用途**：文字列の全ての接尾辞をソートして格納する接尾辞配列
- **特徴**：
	- 接尾辞木よりもメモリ効率が良い
	- 二分探索による効率的なパターンマッチング
- **時間計算量**：
	- 構築: O(m log m)
	- 検索: O(p log m)、ここでpは検索パターンの長さ、mは文字列の長さ
- **空間計算量**：O(m)、ここでmは文字列の長さ

## アルゴリズム（データ構造）選択ガイド

- **基本的なTrie**: 単純な前方一致検索や、完全一致検索が必要な場合に適しています。実装が簡単で理解しやすいという利点があります。
- **CompactTrie/RadixTrie**: メモリ使用量が制限される場合や、共通接頭辞が多いデータセットに適しています。
- **PatriciaTrie**: ビットレベルでの比較が必要な場合や、IPアドレスなどのバイナリデータを扱う場合に適しています。
- **TernarySearchTree**: メモリ効率と検索の柔軟性のバランスが必要な場合に適しています。
- **DoubleArrayTrie**: 静的なデータセットに対して非常に高速な検索が必要な場合に適しています。
- **SuffixTree/SuffixArray**: 部分文字列検索や最長共通部分文字列など、複雑な文字列操作が必要な場合に適しています。

## 注意事項

- 現在、基本的なTrie実装のみが完成しており、他のクラスは計画段階または開発中です。
- トライ木は文字列の集合を扱う場合に非常に効率的ですが、各ノードのオーバーヘッドが大きいため、メモリ使用量が多くなる可能性があります。
- 文字列の長さが長い場合や、文字の種類が多い場合は、メモリ使用量と検索時間のトレードオフを考慮して適切な実装を選択してください。
- 動的な更新が頻繁に行われる場合は、DoubleArrayTrieよりも基本的なTrieやTernarySearchTreeの方が適しています。