# LongSegmentTree 利用ガイド

## 概要

`LongSegmentTree` は、`long` 型の配列に対する範囲クエリと点更新を効率的に処理するための、セグメント木の `long` 特化実装です。
`long` 型の合計、最小値、最大値などを高速に計算する必要がある場合に使用します。

## 特徴

- **`long` 型への特化**:
	- `long` プリミティブ型を直接扱うことで、ジェネリック版の `SegmentTree`
	  で発生するボクシング・アンボクシングのオーバーヘッドをなくし、優れたパフォーマンスを実現します。
- **パフォーマンス**:
	- 配列を利用したボトムアップ方式で実装されており、再帰呼び出しのオーバーヘッドがありません。
	- `set` による更新処理は遅延評価され、`query` 直前にまとめて実行されるため、更新が連続する際の効率が向上します。

## 依存関係

- `java.util.function.LongBinaryOperator`

## 主な機能（メソッド一覧）

### 1. コンストラクタ

| メソッド                                                             | 戻り値の型  | 説明                                                                              |
|------------------------------------------------------------------|--------|---------------------------------------------------------------------------------|
| `LongSegmentTree(int n, LongBinaryOperator func, long identity)` | `void` | サイズ `n`、`long` 型の集約ルールを定義する二項演算 `func`、およびその単位元 `identity` を指定して、セグメント木を初期化します。 |

### 2. 更新系メソッド

| メソッド                 | 戻り値の型  | 説明                                                         |
|----------------------|--------|------------------------------------------------------------|
| `set(int i, long e)` | `void` | インデックス `i` の要素を値 `e` に更新します。更新内容は遅延評価され、キューに積まれます。         |
| `build()`            | `void` | `set` によってキューに積まれた更新を木全体に反映させます。通常、`query` 実行時に自動で呼び出されます。 |

### 3. クエリ系メソッド

| メソッド                  | 戻り値の型  | 説明                                    |
|-----------------------|--------|---------------------------------------|
| `get(int i)`          | `long` | インデックス `i` の現在の値を取得します。               |
| `query(int l, int r)` | `long` | 閉区間 `[l, r]` における集約結果（合計、最小値など）を返します。 |

### 4. その他

| メソッド         | 戻り値の型                      | 説明                         |
|--------------|----------------------------|----------------------------|
| `iterator()` | `PrimitiveIterator.OfLong` | 木が保持する要素（葉）に対するイテレータを返します。 |
| `toString()` | `String`                   | 木の内部状態を整形された文字列として返します。    |

## 利用例

`LongSegmentTree` を使って、配列の範囲合計（Range Sum Query）を管理する例です。

```java
import java.util.function.LongBinaryOperator;

public class LongSegmentTreeExample {
    public static void main(String[] args) {
        // 配列のサイズ
        int n = 10;

        // 演算ルール（今回は合計）
        LongBinaryOperator sumFunc = (a, b) -> a + b;

        // 単位元（合計の場合は 0L）
        long identity = 0L;

        // long 型のセグメント木を初期化
        var segTree = new LongSegmentTree(n, sumFunc, identity);

        // 初期値を設定
        segTree.set(0, 5L);
        segTree.set(1, 3L);
        segTree.set(2, 7L);
        segTree.set(3, 1L);
        segTree.set(4, 8L);

        // 範囲 [1, 3] の合計をクエリ (3L + 7L + 1L = 11L)
        long sum1 = segTree.query(1, 3);
        System.out.println("Sum of range [1, 3]: " + sum1); // -> 11

        // インデックス 2 の値を 10L に更新
        segTree.set(2, 10L);

        // 再度同じ範囲でクエリ (3L + 10L + 1L = 14L)
        long sum2 = segTree.query(1, 3);
        System.out.println("Sum of range [1, 3] after update: " + sum2); // -> 14
    }
}
```

## 注意事項

- クエリ `query(l, r)` の範囲は閉区間 `[l, r]`（`l` と `r` を両方含む）です。
- `build()` メソッドは `query()` 実行時に内部で自動的に呼び出されるため、ユーザーが明示的に呼び出す必要は通常ありません。

## パフォーマンス特性

- **時間計算量**:
	- `set`: $O(\log N)$
	- `query`: $O(\log N)$
	- `get`: $O(1)$
- **空間計算量**:
	- 全体: $O(N)$

## バージョン情報

| バージョン番号       | 年月日        | 詳細   |
|:--------------|:-----------|:-----|
| **バージョン 1.0** | 2025-11-25 | 初回実装 |

### バージョン管理について

バージョン番号は2桁で管理します：

- 1桁目（メジャーバージョン）: メソッドの追加や機能拡張があった場合に更新
- 2桁目（マイナーバージョン）: 誤字修正、バグ修正、マイクロ高速化などの小さな更新があった場合に更新
