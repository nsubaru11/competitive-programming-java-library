# Priority Queue

## 概要

優先度キューは、要素に優先度を付けて管理するデータ構造で、常に最高（または最低）優先度の要素を効率的に取り出すことができます。
このライブラリでは、汎用的な優先度キューと、int型およびlong型に特化した高効率な実装を提供しています。
いずれもバイナリヒープを使用して実装されており、効率的な挿入と削除操作を行います。

## 実装クラス

### [PriorityQueue](./src/PriorityQueue.java)

- **用途**：任意の型の要素を扱う汎用的な優先度キュー
- **特徴**：
	- ジェネリック型をサポート（Comparable<T>を実装する任意の型）
	- カスタムComparatorによる比較をサポート
	- 昇順/降順の指定が可能
	- 動的なサイズ調整（容量が不足すると自動的に拡張）
	- Iterableインターフェースの実装によるfor-each構文のサポート
	- 遅延評価戦略により、大量の要素を一括追加する場合に高速化
- **主な操作**:
	- `push(T v)`: 要素を追加
	- `poll()`: 最高優先度の要素を取り出して削除
	- `peek()`: 最高優先度の要素を参照（削除しない）
	- `replaceTop(T v)`: 先頭要素を置き換える
	- `size()`: 要素数を取得
	- `isEmpty()`: 空かどうかを判定
	- `clear()`: すべての要素を削除
- **時間計算量**：
	- 挿入: O(log n)（遅延評価により実質O(1)の場合あり）
	- 削除: O(log n)
	- 参照: O(1)
- **空間計算量**：O(n)、ここでnは要素数

### [IntPriorityQueue](./src/IntPriorityQueue.java)

- **用途**：int型の要素に特化した優先度キュー
- **特徴**：
	- プリミティブ型の配列を使用し、ボクシング/アンボクシングのオーバーヘッドを回避
	- 昇順/降順の指定が可能
	- 動的なサイズ調整
	- Iterableインターフェースの実装
	- 遅延評価戦略により、大量の要素を一括追加する場合に高速化
	- ジェネリック版と比較して約3〜4倍高速
- **主な操作**:
	- `push(int v)`: 要素を追加
	- `poll()`: 最高優先度の要素を取り出して削除
	- `peek()`: 最高優先度の要素を参照
	- `replaceTop(int v)`: 先頭要素を置き換える
	- `size()`: 要素数を取得
	- `isEmpty()`: 空かどうかを判定
	- `clear()`: すべての要素を削除
- **時間計算量**：
	- 挿入: O(log n)（遅延評価により実質O(1)の場合あり）
	- 削除: O(log n)
	- 参照: O(1)
- **空間計算量**：O(n)

### [LongPriorityQueue](./src/LongPriorityQueue.java)

- **用途**：long型の要素に特化した優先度キュー
- **特徴**：
	- プリミティブ型の配列を使用し、ボクシング/アンボクシングのオーバーヘッドを回避
	- 昇順/降順の指定が可能
	- 動的なサイズ調整
	- Iterableインターフェースの実装
	- 遅延評価戦略により、大量の要素を一括追加する場合に高速化
	- int型の範囲を超える大きな値を扱える
	- ジェネリック版と比較して約3〜4倍高速
- **主な操作**:
	- `push(long v)`: 要素を追加
	- `poll()`: 最高優先度の要素を取り出して削除
	- `peek()`: 最高優先度の要素を参照
	- `replaceTop(long v)`: 先頭要素を置き換える
	- `size()`: 要素数を取得
	- `isEmpty()`: 空かどうかを判定
	- `clear()`: すべての要素を削除
- **時間計算量**：
	- 挿入: O(log n)（遅延評価により実質O(1)の場合あり）
	- 削除: O(log n)
	- 参照: O(1)
- **空間計算量**：O(n)

### [IndexedPriorityQueue](./src/IndexedPriorityQueue.java)

- **用途**：グラフアルゴリズム（ダイクストラ法、Prim法など）に特化した優先度キュー
- **特徴**：
	- 頂点IDとコストを管理し、特定の頂点のコストを効率的に更新・取得・削除できる
	- インデックス付き管理により、O(1)で頂点の存在確認やコスト取得が可能
	- O(log N)でのコスト更新を実現
	- 遅延評価戦略により、大量の頂点を一括追加する場合に高速化
	- relax操作をネイティブサポート
	- 固定容量（頂点数を事前に指定）
- **主な操作**:
	- `push(int node, long cost)`: 頂点とコストを追加
	- `poll()` / `pollNode()`: 最優先要素を取り出して削除
	- `peek()` / `peekNode()`: 最優先要素を参照
	- `peekSecond()`: 2番目の要素を参照
	- `updateCost(int node, long newCost)`: 指定頂点のコストを更新
	- `getCost(int node)`: 指定頂点のコストを取得
	- `remove(int node)`: 指定頂点を削除
	- `contains(int node)`: 指定頂点が存在するか確認
	- `relax(int node, long cost)`: relax操作を実行
	- `pushOrUpdate(int node, long cost)`: 存在しなければ追加、存在すれば更新
- **時間計算量**：
	- 挿入: O(1)（遅延評価）
	- 削除: O(log n)
	- コスト更新: O(log n)
	- コスト取得: O(1)
	- 頂点存在確認: O(1)
- **空間計算量**：O(n)、ここでnは頂点数

## 選択ガイド

| クラス                    | 用途                | 推奨シーン             | 性能特性               |
|------------------------|-------------------|-------------------|--------------------|
| `PriorityQueue<T>`     | 汎用的なオブジェクトの優先度管理  | 文字列、カスタムオブジェクトなど  | 標準的な性能             |
| `IntPriorityQueue`     | int型の値の優先度管理      | 整数値のみを扱う場合        | **約3〜4倍高速**        |
| `LongPriorityQueue`    | long型の値の優先度管理     | int型の範囲を超える値を扱う場合 | **約3〜4倍高速**        |
| `IndexedPriorityQueue` | グラフアルゴリズムでの最短経路計算 | ダイクストラ法、Prim法など   | **コスト更新がO(log n)** |

### 詳細な選択基準

- **PriorityQueue<T>**: 整数以外の型（文字列、カスタムオブジェクトなど）を扱う場合や、カスタムの比較ロジックが必要な場合に使用します。
- **IntPriorityQueue**: int型の値のみを扱う場合に使用します。ボクシング/アンボクシングのオーバーヘッドがないため、整数値を扱う場合はこちらの方が高速です。
- **LongPriorityQueue**: long型の値を扱う場合や、int型の範囲（-21億〜21億）を超える可能性がある場合に使用します。IntPriorityQueueと同様に、プリミティブ型に特化しているため高速です。
- **IndexedPriorityQueue**:
	グラフの最短経路問題（ダイクストラ法）や最小全域木問題（Prim法）など、頂点のコストを頻繁に更新する必要がある場合に使用します。通常の優先度キューでは実現できない、特定頂点のコスト更新をO(
	log N)で行えます。

## 遅延評価戦略について

すべてのクラスで**遅延評価戦略**を採用しています。

### 動作原理

- `push`操作では即座にヒープ化せず、未整列要素として蓄積
- `poll`や`peek`などのヒープ性質を必要とする操作時に、最適なアルゴリズムを自動選択
	- **Floyd's heapify**: O(N) - 多数の要素を一括処理する場合
	- **逐次siftUp**: O(k log N) - 少数の要素を追加する場合

### 性能改善例

| シナリオ         | 従来方式       | 遅延評価版      | 改善率                    |
|--------------|------------|------------|------------------------|
| 100万要素を一括追加  | O(N log N) | O(N)       | **約20倍高速** (N=10^6の場合) |
| 少数要素の段階的追加   | O(k log N) | O(k log N) | 同等（オーバーヘッドは僅か）         |
| 追加と取り出しの混在操作 | O(M log N) | O(M log N) | 同等                     |

この戦略により、使用パターンに応じて自動的に最適化されるため、幅広い状況で高いパフォーマンスを発揮します。

## 注意事項

### 共通の注意事項

- **優先度の保証**: 優先度キューは要素の完全な順序を保持するわけではなく、最高優先度の要素のみを効率的に取り出せることを保証します。
- **イテレータの順序**: イテレータを使用して要素を走査する場合、優先度順ではなく内部配列の順序で走査されることに注意してください。
- **動的なサイズ調整**: 容量が不足すると自動的に拡張されますが、初期容量を適切に設定することで、不要なメモリ再割り当てを避けることができます。
- **要素の優先度変更**: 要素の優先度を変更する場合は、一度取り出して再度追加する必要があります（IndexedPriorityQueueを除く）。

### クラス固有の注意事項

#### PriorityQueue<T>

- null要素は非対応
- ジェネリック型Tは`Comparable<T>`を実装している必要があります（Comparatorを指定する場合を除く）
- オートボクシングのオーバーヘッドが発生するため、プリミティブ型を大量に扱う場合は専用クラスを推奨

#### IntPriorityQueue / LongPriorityQueue

- 空キューでの`poll()`/`peek()`呼び出しは`NoSuchElementException`をスローします
- int型は約-21億〜21億、long型は約-922京〜922京の範囲のみ扱えます

#### IndexedPriorityQueue

- 頂点数は構築時に指定し、後から変更できません
- 頂点IDは0以上n未満である必要があります
- 同じ頂点を2回`push`すると`IllegalArgumentException`がスローされます
- 存在しない頂点に対する操作は`NoSuchElementException`をスローします

## パフォーマンス比較

### メモリ使用量（100万要素）

| クラス                    | メモリ使用量 | 備考               |
|------------------------|--------|------------------|
| `PriorityQueue<T>`     | 約32MB  | オブジェクト参照のオーバーヘッド |
| `IntPriorityQueue`     | 約4MB   | プリミティブ配列         |
| `LongPriorityQueue`    | 約8MB   | プリミティブ配列         |
| `IndexedPriorityQueue` | 約16MB  | 3配列管理            |

### 実測性能例（Java 17、100万要素）

| 操作             | PriorityQueue<T> | IntPriorityQueue | 性能比    |
|----------------|------------------|------------------|--------|
| push (100万回)   | 約300ms           | 約80ms            | 3.8倍高速 |
| poll (100万回)   | 約250ms           | 約70ms            | 3.6倍高速 |
| push+poll (交互) | 約400ms           | 約120ms           | 3.3倍高速 |

※環境やJVM設定により結果は変動します

## ライセンス

このライブラリは競技プログラミング用途に自由に使用できます。

## バージョン情報

- **PriorityQueue**: v2.0 (2025-10-08) - 遅延評価戦略、replaceTopメソッド追加
- **IntPriorityQueue**: v2.0 (2025-10-08) - 遅延評価戦略、replaceTopメソッド追加
- **LongPriorityQueue**: v2.0 (2025-10-08) - 遅延評価戦略、replaceTopメソッド追加
- **IndexedPriorityQueue**: v2.0 (2025-10-08) - 降順対応強化、javadocコメント統一

詳細は各クラスの利用ガイドを参照してください。