# 二分探索木 (Binary Search Tree)

## 概要

二分探索木は、効率的な検索、挿入、削除操作を提供するデータ構造です。このライブラリでは、基本的な二分探索木の実装と、将来的に実装予定の自己平衡二分探索木（AVL木、赤黒木、B木）のクラスを提供しています。

## 実装クラス

### [BinarySearchTree](./src/BinarySearchTree.java)

- **用途**：汎用的な二分探索木の実装で、要素の追加、検索、削除などの基本操作を提供
- **特徴**：
	- ジェネリック型をサポート（Comparable<T>を実装する任意の型）
	- カスタムComparatorによる比較をサポート
	- 境界検索機能（higher, ceiling, lower, floor）を提供
	- イテレータによる要素の走査をサポート
- **主な操作**:
	- `add(T n)`: 要素を追加
	- `remove(T n)`: 要素を削除
	- `indexOf(T n)`: 要素のインデックスを取得
	- `get(int idx)`: インデックスから要素を取得
	- `higher(T n)`, `ceiling(T n)`, `lower(T n)`, `floor(T n)`: 境界検索
- **時間計算量**：
	- 検索/挿入/削除: 平均 O(log n)、最悪 O(n)
	- 走査: O(n)
- **空間計算量**：O(n)、ここでnは要素数

### [BinarySearchTreeTemp](./src/BinarySearchTreeTemp.java)

- **用途**：BinarySearchTreeの代替実装で、同様の機能を提供
- **特徴**：
	- BinarySearchTreeと同様の機能セット
	- 実装の詳細が若干異なる
- **時間計算量**：
	- 検索/挿入/削除: 平均 O(log n)、最悪 O(n)
	- 走査: O(n)
- **空間計算量**：O(n)、ここでnは要素数

### [AVL](./src/AVL.java) (開発中)

- **用途**：自己平衡二分探索木の一種で、常に平衡状態を維持
- **特徴**：
	- 高さバランスを保証（任意のノードの左右の部分木の高さの差が1以下）
	- 検索、挿入、削除操作が常に O(log n) の時間計算量
- **時間計算量**：
	- 検索/挿入/削除: O(log n)
- **空間計算量**：O(n)

### [RedBlackTree](./src/RedBlackTree.java) (計画中)

- **用途**：自己平衡二分探索木の一種で、赤黒規則に従って平衡を維持
- **特徴**：
	- 各ノードに色（赤または黒）を付与
	- 特定の規則に従って平衡を維持
- **時間計算量**：
	- 検索/挿入/削除: O(log n)
- **空間計算量**：O(n)

### [BTree](./src/BTree.java) (計画中)

- **用途**：多分岐の自己平衡探索木で、ディスクアクセスを最小化
- **特徴**：
	- 各ノードが複数の子を持つことが可能
	- ディスクI/Oに最適化された構造
- **時間計算量**：
	- 検索/挿入/削除: O(log n)
- **空間計算量**：O(n)

## アルゴリズム（データ構造）選択ガイド

- **BinarySearchTree**: メモリ使用量が重要で、データが比較的ランダムに分布している場合に適しています。実装がシンプルで理解しやすいという利点があります。
- **AVL木** (開発中): 検索操作が頻繁に行われ、厳密な平衡性が必要な場合に適しています。
- **赤黒木** (計画中): 挿入/削除操作が頻繁に行われる場合に適しています。AVL木よりも回転操作が少なく、実用的なシナリオで効率的です。
- **B木** (計画中): 大量のデータを扱い、ディスクアクセスを最小化する必要がある場合に適しています。

## 注意事項

- 基本的な二分探索木（BinarySearchTree,
	BinarySearchTreeTemp）は、最悪の場合（ソートされたデータを順に挿入する場合など）に線形時間（O(n)）の操作時間になる可能性があります。
- 自己平衡木の実装（AVL, RedBlackTree, BTree）は現在開発中または計画中の段階です。
- 要素の比較には、デフォルトでComparable<T>インターフェースが使用されますが、コンストラクタでカスタムComparatorを指定することも可能です。