### 📝 Java `FastPrinter`における文字列出力の厳密な性能分析レポート

#### 1\. 目的

本レポートは、Javaにおける高速な文字列出力を実現するため、2つの異なる`FastPrinter`
クラスの実装の性能を100回のベンチマーク実行に基づき比較・分析し、統計的および実証的に最適な実装を特定することを目的とします。

-----

#### 2\. テスト環境と分析手法

- **実行環境**:
	- OS: Windows 11 （UTF-8有効）
	- JVMオプション: `-Xms2g -Xmx2g -XX:+AlwaysPreTouch`
- **分析手法**:
	- 各実装パターンをそれぞれ**100回**、独立したプロセスとして実行 。
	- 基本統計量（平均、中央値、標準偏差など）を算出。
	- **箱ひげ図**（の想定）を用いて実行時間の分布を視覚的に評価。
	- **t検定**（有意水準 $\\alpha = 0.05$）を用いて、メソッド間の平均性能差の統計的有意性を評価。

-----

#### 3\. 分析対象の実装パターン

性能に決定的な差を生む、文字列のバイトバッファへのコピー方法が異なる2つの実装をテストしました 。

| メソッド名              | 実装のアプローチ                                                                                          |
|:-------------------|:--------------------------------------------------------------------------------------------------|
| **`FastPrinter0`** | `String.charAt(i)`を用いて1文字ずつループでバッファにコピーする、標準的な手法。                                                 |
| **`FastPrinter1`** | `sun.misc.Unsafe` APIを使用し、Stringの内部`byte[]`配列に直接アクセス。`System.arraycopy`でバッファに一括コピーする、高度に最適化された手法。 |

-----

#### 4\. ベンチマーク結果と考察

##### 4.1. 最終結果サマリ

全100回の実行結果 (`output4.txt`)¹ に基づく詳細な統計値は以下の通りです。

| メソッド名                 | 平均 (ms)     | 中央値 (ms)    | 最小 (ms)     | 最大 (ms)      | 標準偏差 (ms)   |
|:----------------------|:------------|:------------|:------------|:-------------|:------------|
| `FastPrinter0`        | 11466.91    | 8781.13     | 5385.81     | 38257.31     | 6184.87     |
| 🥇 **`FastPrinter1`** | **6843.51** | **5174.00** | **1575.06** | **39458.71** | **6070.79** |

¹*各実行は独立したプロセスであるため、ウォームアップ期間は考慮せず全データを使用。*

##### 4.2. 詳細分析

- **📊 データ分布の視覚的分析**
	箱ひげ図を想定すると、`FastPrinter1`の実行時間分布（箱）は`FastPrinter0`よりも著しく低い位置にあり、*
	*典型的なパフォーマンス（中央値）が圧倒的に優れている**ことがわかります。`FastPrinter1`の中央値は約5174msであり、
	`FastPrinter0`の約8781msを大幅に下回っています。

- **⚙️ 統計的有意性の評価**
	t検定の結果、p値は**0.0001未満**となりました。これは、2つのメソッドの平均性能に**統計的に極めて有意な差がある**ことを示しており、
	`FastPrinter1`の優位性は偶然ではありません。

- **🚀 パフォーマンスの安定性に関する考察**
	両メソッドともに**標準偏差が非常に大きく、パフォーマンスが不安定**
	であることが今回の分析で明らかになりました。特に、最大値が30000msを超える外れ値が双方で観測されており、これはJITコンパイラの挙動だけでなく、OSのI/Oスケジューリングやキャッシュ、ガベージコレクションなど、低レベルな要因が複雑に影響していることを示唆しています。
	`FastPrinter1`は中央値では圧勝していますが、このようなシステムレベルの要因による性能の揺らぎからは逃れられていません。しかし、その
	**典型的な性能は`FastPrinter0`を遥かに凌駕**しています。

-----

#### 5\. 結論：最終的な推奨実装

🚀 以上の厳密な分析から、\*\*性能を最優先する場合の最適解は`FastPrinter1`\*\*であると結論付けます。

`FastPrinter1`は、`sun.misc.Unsafe`を用いてJavaの抽象化を回避し、メモリ（Stringの内部バイト配列）を直接操作することで、標準的な実装である
`FastPrinter0`を圧倒する速度を達成しています。

ただし、この高性能には以下の重要な注意点が存在します。

- **危険性と非互換性**: `sun.misc.Unsafe`
	は公式にサポートされていない内部APIです。JVMのバージョンやベンダーが変わると動作しなくなる可能性があり、使い方を誤るとJVMをクラッシュさせる危険性もあります。

したがって、競技プログラミングのような実行速度が絶対的に求められ、環境が固定されている場面でのみ使用が許容されるべき「諸刃の剣」と言えます。

**推奨実装 (`FastPrinter1`の主要部分)**:

```java
public FastPrinter1 println(final String s) {
    // Unsafe APIでStringの内部バイト配列を直接取得
    final byte[] src = (byte[]) UNSAFE.getObject(s, STRING_VALUE_OFFSET);
    // 内部バッファにバイト配列をコピー
    fillBuffer(src, s.length());
    ensureBufferSpace(1);
    buffer[pos++] = '\n';
    if (autoFlush) flush();
    return this;
}
```