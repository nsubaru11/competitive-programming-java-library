### 📝 Java `FastScanner`における`long`型配列読み込みの厳密な性能分析レポート

#### 1\. 目的

本レポートは、Javaにおける高速な入力処理を実現するため、`FastScanner`クラスで`long`型配列を読み込む際の2つの異なる実装（`for`ループ vs `Arrays.setAll`）の性能を100回の実行結果に基づき比較・分析し、統計的および実証的に最適な実装を特定することを目的とする。

-----

#### 2\. テスト環境と分析手法

  * **実行環境**:
      * OS: Windows 11 (UTF-8)
      * JVMオプション: `-Xms2g -Xmx2g -XX:+AlwaysPreTouch`
  * **テストデータ**:
      * `TestCase_LongNumbers_123456789.txt`: 正負の`long`値が混在するデータセット（**混合データ**）。
      * `TestCase_PositiveLongNumbers_123456789.txt`: 正の`long`値のみのデータセット（**正の整数データ**）。
  * **測定と分析**:
      * 各実装パターンをそれぞれ**100回**実行し、`System.nanoTime()`で実行時間を測定。
      * 基本統計量（平均、中央値、標準偏差など）を算出。
      * **箱ひげ図**を用いて実行時間の分布を視覚的に評価。
      * **t検定**（有意水準 $\\alpha = 0.05$）を用いて、メソッド間の平均性能差が統計的に有意であるかを評価。

-----

#### 3\. 分析対象の実装パターン

配列への値の代入方法が異なる2つの実装 (`TestInputLongArray.java` に記載) をテストしました。

| メソッド名 | 実装のアプローチ |
| :--- | :--- |
| **`nextLong0`** | 伝統的な`for`ループによる逐次代入 |
| **`nextLong1`** | `Arrays.setAll`メソッドとラムダ式による一括初期化 |

-----

#### 4\. ベンチマーク結果と考察

##### 4.1. 最終結果サマリ

全100回の実行結果¹に基づく詳細な統計値は以下の通りです。

**混合データ (`output2_1.txt`)**
| メソッド名 | 平均 (ms) | 中央値 (ms) | 最小 (ms) | 最大 (ms) | 標準偏差 (ms) |
| :--- | :--- | :--- | :--- | :--- | :--- |
| 🥇 **`for`ループ** | 6259.66 | **5343.28** | 4956.43 | 15641.76 | **1977.62** |
| `Arrays.setAll` | 7087.46 | 7169.84 | 6076.70 | 7738.88 | 388.86 |

**正の整数データ (`output2_2.txt`)**
| メソッド名 | 平均 (ms) | 中央値 (ms) | 最小 (ms) | 最大 (ms) | 標準偏差 (ms) |
| :--- | :--- | :--- | :--- | :--- | :--- |
| 🥇 **`for`ループ** | **4841.27** | **4816.32** | **4521.48** | 6628.29 | **237.74** |
| `Arrays.setAll` | 5244.58 | 5311.13 | 4629.52 | 6223.61 | 408.10 |

¹*ご指摘に基づき、各実行は独立したプロセスであるため、ウォームアップ期間は考慮せず全データを使用。*

##### 4.2. 詳細分析

  * **📊 データ分布の視覚的分析**
    箱ひげ図を見ると、両方のデータセットで`for`ループの実行時間分布（箱）が`Arrays.setAll`よりも明確に低い位置にあります。これは`for`ループの**典型的なパフォーマンス（中央値）が優れている**ことを示しています。特に正の整数データにおいては、ばらつきも少なく非常に安定していることがわかります。

  * **⚙️ 統計的有意性の評価**
    メソッド間の平均性能差が偶然でないかt検定で評価しました。

      * **混合データ**: p値 \< 0.0001
      * **正の整数データ**: p値 \< 0.0001
        両方のケースでp値は極めて小さく、`for`ループと`Arrays.setAll`の**平均性能には統計的に有意な差がある**と断定できます。

  * **🚀 パフォーマンスの安定性に関する考察**
    今回の分析で最も重要な点は、**混合データにおける`for`ループの性能の不安定さ**です。標準偏差が**1977.62ms**と極めて大きく、`Arrays.setAll`の5倍以上に達しています。これは、テスト方式（毎回JVMを新規起動）において、`nextLong`内の負数判定の分岐処理に対するJITコンパイラの最適化が実行ごとに大きく変動し、時として著しく低い性能を示したためです。一方で、分岐が固定される正の整数データでは、`for`ループは非常に安定した性能を発揮しました。
    この結果から、`for`ループは最高のポテンシャルを持ちますが、**入力データと実行条件によっては性能が不安定になるリスク**も抱えていることがわかります。

-----

#### 5\. 結論：最終的な推奨実装

🚀 以上の厳密な分析から、総合的に判断して\*\*`for`ループによる実装 (`nextLong0`) が最適解\*\*であると結論付けます。

**典型的な実行時間（中央値）では両方のデータセットで`Arrays.setAll`を圧倒**しており、その性能ポテンシャルは明らかです。ただし、混合データを扱う際の性能のばらつきには注意が必要です。

競技プログラミングなど、平均的な速さが求められる場面では、この実装が最良の選択となります。

```java
public long[] nextLong0(int n) {
    long[] arr = new long[n];
    for (int i = 0; i < n; i++) arr[i] = nextLong();
    return arr;
}
```