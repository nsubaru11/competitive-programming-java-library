### 📝 Java `FastScanner`における`nextDouble`メソッドの厳密な性能分析レポート

#### 1\. 目的

本レポートは、Javaにおける高速な入力処理を実現するため、`FastScanner`クラスの`nextDouble`メソッドについて、3つの異なる実装パターンの性能を100回の実行結果に基づき比較・分析し、統計的および実証的に最も高速かつ安定した実装を特定することを目的とする。

-----

#### 2\. テスト環境と分析手法

  * **実行環境**:
      * OS: Windows 11 (UTF-8)
      * JVMオプション: `-Xms2g -Xmx2g -XX:+AlwaysPreTouch`
  * **テストデータ**:
      * `TestCase_DoubleNumbers_123456789.txt`: 大量の浮動小数点数を含むデータセット。
  * **測定と分析**:
      * 各実装パターンをそれぞれ**100回**実行し、`System.nanoTime()`で実行時間を測定。
      * 基本統計量（平均、中央値、標準偏差など）を算出。
      * **箱ひげ図**を用いて実行時間の分布を視覚的に評価。
      * **t検定**（有意水準 $\\alpha = 0.05$）を用いて、メソッド間の平均性能差が統計的に有意であるかを評価。

-----

#### 3\. 分析対象の実装パターン

性能に影響を与える「小数部分の計算方法」と「整数部分の計算方法」の組み合わせが異なる3つの実装をテストしました。

| 分析項目 | パターンA | パターンB |
| :--- | :--- | :--- |
| **小数部分の計算** | `long`で計算後、最後に`double`で除算 | `double`のスケール変数で逐次加算 |
| **整数部分の計算** | 標準的な乗算 (`* 10`) | ビットシフト演算 |

  * [cite\_start]**`nextDouble0`**: 小数部分: A, 整数部分: A [cite: 1]
  * [cite\_start]**`nextDouble1`**: 小数部分: B, 整数部分: A [cite: 1]
  * [cite\_start]**`nextDouble2`**: 小数部分: B, 整数部分: B [cite: 1]

-----

#### 4\. ベンチマーク結果と考察

##### 4.1. 最終結果サマリ

100回実行の詳細な統計値は以下の通りです。`nextDouble0`はウォームアップ後¹の数値です。

| メソッド名 | 平均 (ms) | 中央値 (ms) | 最小 (ms) | 最大 (ms) | 標準偏差 (ms) |
| :--- | :--- | :--- | :--- | :--- | :--- |
| `nextDouble0`¹ | 2220.18 | 2213.14 | 2111.65 | 2588.42 | 68.27 |
| `nextDouble1` | 1888.75 | 1865.85 | 1760.96 | 2940.57 | 156.49 |
| 🥇 **`nextDouble2`** | **1887.65** | **1876.02** | **1798.01** | **2034.69** | **64.73** |

¹\*`nextDouble0`の最初の6回の実行はJITコンパイラのウォームアップによる外れ値と判断し、分析から除外。\*

##### 4.2. 詳細分析

  * **📊 データ分布の視覚的分析**
    箱ひげ図から、`nextDouble2`の実行時間分布（箱）が最も低い位置にあり、上下のひげ（ばらつきの範囲）も短いことがわかります。これは、`nextDouble2`が**平均的により高速であるだけでなく、実行時間のばらつきが最も少なく安定している**ことを視覚的に示しています。`nextDouble1`も高速ですが、いくつかの外れ値（点）が見られ、時折性能が低下したことを示唆しています。

  * **⚙️ 統計的有意性の評価**
    メソッド間の平均性能差が偶然によるものでないかt検定で評価しました。

      * **`nextDouble1` vs `nextDouble2`**: p値が **0.94** となり、2つのメソッドの平均性能に**統計的に意味のある差はない**と結論付けられます。
      * **`nextDouble0` vs `nextDouble2`**: p値が **0.00001未満** となり、`nextDouble2`が`nextDouble0`よりも**統計的に有意に高速である**ことが確認されました。

  * **🚀 パフォーマンスの安定性に関する考察**
    t検定では`nextDouble1`と`nextDouble2`の「平均値」に有意差はありませんでした。しかし、**標準偏差**（ばらつきの大きさ）を見ると、`nextDouble2` (64.73) は `nextDouble1` (156.49) の半分以下です。これは、`nextDouble2`のパフォーマンスが**圧倒的に安定しており、予測可能である**ことを意味します。競技プログラミングのような最悪ケースの実行時間が重要となる場面では、平均速度が同等でも、安定性が高い実装がより好ましい選択となります。

-----

#### 5\. 結論：最終的な推奨実装

🚀 以上の厳密な分析から、`nextDouble2`が総合的に最も優れた実装であると結論付けます。

`nextDouble1`と平均性能は統計的に同等ですが、`nextDouble2`は**実行時間のばらつきが極めて小さく、パフォーマンスが非常に安定**しています。この安定性は、どのような入力が来ても一貫した高速性を保証する上で重要な要素です。

したがって、最速かつ最も信頼性の高い実装として、以下の`nextDouble2`を最適解として推奨します。

```java
public double nextDouble2() {
    int b = skipSpaces();
    boolean negative = false;

    if (b != '-') {
        // Positive numbers
    } else {
        negative = true;
        b = read();
    }

    double result = 0;
    // ビットシフトによる高速な整数部計算
    while ('0' <= b && b <= '9') {
        result = ((long) result << 3) + ((long) result << 1) + (b & 15);
        b = read();
    }

    // スケール変数による高速な小数部計算
    if (b == '.') {
        b = read();
        double scale = 0.1;
        while ('0' <= b && b <= '9') {
            result += (b & 15) * scale;
            scale *= 0.1;
            b = read();
        }
    }

    return negative ? -result : result;
}
```