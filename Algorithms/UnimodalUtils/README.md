# 三分探索 (Ternary Search) アルゴリズム

## 概要

三分探索は、単峰性（Unimodal）を持つ関数の極値（最大値または最小値）を効率的に見つけるためのアルゴリズムです。二分探索が単調増加または単調減少する関数に対して使用されるのに対し、三分探索は関数が最初に増加し、その後減少する（または逆）場合に適しています。

## 実装クラス（開発中）

### [TernarySearch](./src/TernarySearch.java)

- **用途**: 単峰性を持つ関数の極値を効率的に見つけるアルゴリズム
- **特徴**:
	- 連続的な関数の極値を対数時間で見つける
	- 探索範囲を3つの部分に分割して効率的に探索
	- 実数区間と整数区間の両方に適用可能
- **時間計算量**: O(log n)、ここでnは探索範囲のサイズ
- **空間計算量**: O(1)
- **注**: 現在の実装は不完全です

## 基本的な考え方

三分探索は以下のステップで動作します：

1. 探索範囲 [left, right] を設定
2. 範囲を3つの部分に分割するために、2つの中間点 mid1 = left + (right - left) / 3 と mid2 = right - (right - left) / 3 を計算
3. f(mid1) と f(mid2) を評価
4. 極大値を探す場合：
	- f(mid1) > f(mid2) なら、極大値は [left, mid2] の範囲にある
	- f(mid1) < f(mid2) なら、極大値は [mid1, right] の範囲にある
	- f(mid1) = f(mid2) なら、極大値は [mid1, mid2] の範囲にある
5. 極小値を探す場合は、比較の向きを逆にする
6. 新しい範囲で1-5のステップを繰り返し、範囲が十分に小さくなるまで続ける

## 使用例（将来的な実装）

```java
// 連続関数の最大値を見つける例
double maxX = TernarySearch.findMaximum(0.0, 10.0, 1e-9, x -> -x * x + 5 * x + 3);
System.out.

println("最大値のx座標: "+maxX);  // 2.5を出力

// 連続関数の最小値を見つける例
double minX = TernarySearch.findMinimum(-5.0, 5.0, 1e-9, x -> x * x + 2 * x + 1);
System.out.

println("最小値のx座標: "+minX);  // -1.0を出力

// 整数配列の最大値を見つける例（単峰性配列の場合）
int[] arr = {1, 3, 5, 7, 9, 11, 8, 6, 4, 2};
int peakIndex = TernarySearch.findPeakIndex(arr, 0, arr.length - 1);
System.out.

println("ピーク要素のインデックス: "+peakIndex);  // 5を出力（値11）
```

## 応用例

三分探索は以下のような問題に適用できます：

1. **単峰性関数の極値を見つける**：
	- 放物線の頂点
	- 距離の最小値/最大値
	- 利益/コスト関数の最適値

2. **2次元三分探索**：
	- 2変数関数の極値を見つける（入れ子の三分探索）
	- 地形の最高点/最低点

3. **離散的な単峰性配列**：
	- 山型の配列のピーク要素
	- 先に増加し後に減少する（またはその逆の）データセット内の変曲点

## 二分探索との比較

| 特性     | 二分探索     | 三分探索          |
|--------|----------|---------------|
| 対象関数   | 単調増加/減少  | 単峰性（Unimodal） |
| 探索対象   | 特定の値     | 極値（最大/最小）     |
| 分割数    | 2分割      | 3分割           |
| 時間計算量  | O(log n) | O(log n)      |
| 関数評価回数 | 各ステップで1回 | 各ステップで2回      |

## 注意事項

- 三分探索は対象の関数が単峰性を持つ場合にのみ正しく動作します
- 浮動小数点数を扱う場合は、数値誤差に注意する必要があります
- 現在の実装は不完全または開発中です
- 将来的なバージョンでは、より効率的で完全な実装が提供される予定です