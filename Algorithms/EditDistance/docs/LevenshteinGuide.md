# Levenshtein 利用ガイド

## 概要

Levenshteinクラスは、2つの文字列（または文字配列、整数配列）間のレーベンシュタイン距離（編集距離）を計算するためのユーティリティクラスです。レーベンシュタイン距離とは、一方の文字列を他方に変換するために必要な最小の編集操作（挿入、削除、置換）の回数を表します。

## 特徴

- 複数のデータ型（String、char[]、int[]）に対応した編集距離計算メソッドを提供
- メモリ効率の良い実装（2次元配列ではなく、2つの1次元配列を使用）
- 最大許容距離（k）を指定することで、早期終了による高速化が可能
- 文字列の長さの差が最大許容距離を超える場合の即時判定による最適化
- 計算中の最小距離を追跡し、最大許容距離を超えた場合の早期終了による最適化

## 依存関係

このクラスは以下のJava標準ライブラリに依存しています：

- java.lang.Math.abs
- java.lang.Math.min
- java.util.Arrays.setAll

## 主な機能（メソッド一覧）

### 1. 文字列間の編集距離計算メソッド

| メソッド                                           | 戻り値の型 | 説明                                    |
|------------------------------------------------|-------|---------------------------------------|
| computeEditDistance(String s, String t)        | int   | 2つの文字列間の編集距離を計算します                    |
| computeEditDistance(String s, String t, int k) | int   | 2つの文字列間の編集距離を計算します。距離がkを超える場合は-1を返します |

### 2. 文字配列間の編集距離計算メソッド

| メソッド                                           | 戻り値の型 | 説明                                     |
|------------------------------------------------|-------|----------------------------------------|
| computeEditDistance(char[] s, char[] t)        | int   | 2つの文字配列間の編集距離を計算します                    |
| computeEditDistance(char[] s, char[] t, int k) | int   | 2つの文字配列間の編集距離を計算します。距離がkを超える場合は-1を返します |

### 3. 整数配列間の編集距離計算メソッド

| メソッド                                         | 戻り値の型 | 説明                                     |
|----------------------------------------------|-------|----------------------------------------|
| computeEditDistance(int[] s, int[] t)        | int   | 2つの整数配列間の編集距離を計算します                    |
| computeEditDistance(int[] s, int[] t, int k) | int   | 2つの整数配列間の編集距離を計算します。距離がkを超える場合は-1を返します |

## 利用例

```java
// 基本的な編集距離の計算
String s1 = "kitten";
String s2 = "sitting";
int distance = Levenshtein.computeEditDistance(s1, s2);
System.out.println("編集距離: " + distance);  // 出力: 編集距離: 3

// 最大許容距離を指定した編集距離の計算
int maxDistance = 2;
int result = Levenshtein.computeEditDistance(s1, s2, maxDistance);
System.out.println("結果: " + result);  // 出力: 結果: -1（距離が2を超えるため）

// 文字配列を使用した編集距離の計算
char[] c1 = {'h', 'e', 'l', 'l', 'o'};
char[] c2 = {'h', 'a', 'l', 'l', 'o'};
int charArrayDistance = Levenshtein.computeEditDistance(c1, c2);
System.out.println("文字配列の編集距離: " + charArrayDistance);  // 出力: 文字配列の編集距離: 1

// 整数配列を使用した編集距離の計算
int[] a1 = {1, 2, 3, 4, 5};
int[] a2 = {1, 3, 4, 5, 6};
int intArrayDistance = Levenshtein.computeEditDistance(a1, a2);
System.out.println("整数配列の編集距離: " + intArrayDistance);  // 出力: 整数配列の編集距離: 2
```

## 注意事項

- 編集距離の計算は、文字列の長さに対して二次計算量（O(n*m)）を持ちます
- 最大許容距離（k）を指定すると、計算が早期終了する可能性があり、パフォーマンスが向上します
- 文字列の長さの差が最大許容距離（k）を超える場合、計算せずに-1を返します
- 最大許容距離を指定したメソッドは、距離がkを超える場合に-1を返します

## パフォーマンス特性

- 時間計算量: O(n*m)、ここでnとmは2つの入力配列の長さです
- 空間計算量: O(min(n,m))、常に短い方の配列に対してのみメモリを確保します
- 最大許容距離（k）を指定した場合、最悪の時間計算量は変わりませんが、平均的なケースでは早期終了により高速化されます
- すべてのメソッドは、メモリ効率を最適化するために2つの1次元配列のみを使用します

## バージョン情報

| バージョン番号       | 年月日        | 詳細                     |
|:--------------|:-----------|:-----------------------|
| **バージョン 1.0** | 2025-07-11 | 初期実装                   |
| **バージョン 1.1** | 2025-07-21 | すべてのメソッドにメモリ効率の良い実装を適用 |

### バージョン管理について

バージョン番号は2桁で管理します：

- 1桁目（メジャーバージョン）: メソッドの追加や機能拡張があった場合に更新
- 2桁目（マイナーバージョン）: 誤字修正、バグ修正、マイクロ高速化などの小さな更新があった場合に更新