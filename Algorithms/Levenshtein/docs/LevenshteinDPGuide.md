# LevenshteinDP 利用ガイド

## 概要

LevenshteinDPクラスは、2つの文字列（または文字配列、整数配列）間のレーベンシュタイン距離（編集距離）を計算するためのユーティリティクラスです。
レーベンシュタイン距離とは、一方の文字列を他方に変換するために必要な最小の編集操作（挿入、削除、置換）の回数を表します。

## 特徴

- 複数のデータ型（String、char[]、int[]）に対応した編集距離計算メソッドを提供
- メモリ効率の良い実装（2次元配列ではなく、2つの1次元配列を使用）
- 最大許容距離（k）を指定することで、bandedDPアルゴリズムによる高速化（O(|S|K)の時間計算量）
- 文字列の長さの差が最大許容距離を超える場合の即時判定による最適化
- bandedDPアルゴリズムは、編集距離がk以下の場合、実際の変更はダイアゴナルから最大でもk離れた位置にしか現れないという性質を利用

## 依存関係

このクラスは以下のJava標準ライブラリに依存しています：

- java.lang.Math.abs
- java.lang.Math.min
- java.util.Arrays.setAll

## 主な機能（メソッド一覧）

### 1. 文字列間の編集距離計算メソッド

| メソッド                                           | 戻り値の型 | 説明                                    |
|------------------------------------------------|-------|---------------------------------------|
| computeEditDistance(String s, String t)        | int   | 2つの文字列間の編集距離を計算します                    |
| computeEditDistance(String s, String t, int k) | int   | 2つの文字列間の編集距離を計算します。距離がkを超える場合は-1を返します |

### 2. 文字配列間の編集距離計算メソッド

| メソッド                                           | 戻り値の型 | 説明                                     |
|------------------------------------------------|-------|----------------------------------------|
| computeEditDistance(char[] s, char[] t)        | int   | 2つの文字配列間の編集距離を計算します                    |
| computeEditDistance(char[] s, char[] t, int k) | int   | 2つの文字配列間の編集距離を計算します。距離がkを超える場合は-1を返します |

### 3. 整数配列間の編集距離計算メソッド

| メソッド                                         | 戻り値の型 | 説明                                     |
|----------------------------------------------|-------|----------------------------------------|
| computeEditDistance(int[] s, int[] t)        | int   | 2つの整数配列間の編集距離を計算します                    |
| computeEditDistance(int[] s, int[] t, int k) | int   | 2つの整数配列間の編集距離を計算します。距離がkを超える場合は-1を返します |

## 利用例

```java
// 基本的な編集距離の計算
String s1 = "kitten";
String s2 = "sitting";
int distance = LevenshteinDP.computeEditDistance(s1, s2);
System.out.println("編集距離: " + distance);  // 出力: 編集距離: 3

// 最大許容距離を指定した編集距離の計算
int maxDistance = 2;
int result = LevenshteinDP.computeEditDistance(s1, s2, maxDistance);
System.out.println("結果: " + result);  // 出力: 結果: -1（距離が2を超えるため）

// 文字配列を使用した編集距離の計算
char[] c1 = {'h', 'e', 'l', 'l', 'o'};
char[] c2 = {'h', 'a', 'l', 'l', 'o'};
int charArrayDistance = LevenshteinDP.computeEditDistance(c1, c2);
System.out.println("文字配列の編集距離: " + charArrayDistance);  // 出力: 文字配列の編集距離: 1

// 整数配列を使用した編集距離の計算
int[] a1 = {1, 2, 3, 4, 5};
int[] a2 = {1, 3, 4, 5, 6};
int intArrayDistance = LevenshteinDP.computeEditDistance(a1, a2);
System.out.println("整数配列の編集距離: " + intArrayDistance);  // 出力: 整数配列の編集距離: 2
```

## 注意事項

- 編集距離の計算は、文字列の長さに対して二次計算量（O(n*m)）を持ちます
- 最大許容距離（k）を指定すると、計算が早期終了する可能性があり、パフォーマンスが向上します
- 文字列の長さの差が最大許容距離（k）を超える場合、計算せずに-1を返します
- 最大許容距離を指定したメソッドは、距離がkを超える場合に-1を返します

## パフォーマンス特性

- 基本的な実装の時間計算量: O(n*m)、ここでnとmは2つの入力配列の長さです
- 最大許容距離（k）を指定した場合の時間計算量: O(|S|K)、ここで|S|は短い方の配列の長さ、Kは最大許容距離です
- 空間計算量:
	- 基本的な実装: O(min(n,m))、常に短い方の配列に対してのみメモリを確保します
	- bandedDP実装: O(K)、Kは最大許容距離です
- bandedDPアルゴリズムは、編集距離がk以下の場合に特に効率的で、大きな配列でも高速に計算できます
- すべてのメソッドは、メモリ効率を最適化するために2つの1次元配列のみを使用します

## バージョン情報

| バージョン番号       | 年月日        | 詳細                                                   |
|:--------------|:-----------|:-----------------------------------------------------|
| **バージョン 1.0** | 2025-07-11 | 初期実装                                                 |
| **バージョン 1.1** | 2025-07-21 | すべてのメソッドにメモリ効率の良い実装を適用                               |
| **バージョン 1.2** | 2025-07-22 | すべての最大許容距離（k）指定メソッドにbandedDPアルゴリズム（O(\|S\|K)）を適用し高速化 |

### バージョン管理について

バージョン番号は2桁で管理します：

- 1桁目（メジャーバージョン）: メソッドの追加や機能拡張があった場合に更新
- 2桁目（マイナーバージョン）: 誤字修正、バグ修正、マイクロ高速化などの小さな更新があった場合に更新

## 🚀 編集距離を高速に求めるための実装ガイド

以下では、
1. Banded DP（帯状動的計画法）、
2. Wu のアルゴリズム（Myers-Wu 変形）  
	 の 2 手法について、実装の流れ・要点・落とし穴を **もう一度** 整理します。  
	 両者とも「差分が小さい場合に高速」という目的は同じですが、設計思想が異なるため、手順を混在させないことが重要です。

---

### 1️⃣ Banded DP（帯状 DP）実装ガイド

| 項目 | 内容 |
|---|---|
| 目的 | 編集距離 ≤ K であるかどうか／距離そのものを求める |
| 時間計算量 | O(|S| × K) |
| メモリ | O(|S| + K) ― 2 行ぶんをローリングバッファで保持 |

#### 実装手順（Java）

1. **前処理**
	* 長さが短い方を `s`, 長い方を `t` と決める。
	* `sLen`, `tLen`, 許容距離 `K` を取得。
2. **バンド幅とオフセット**
	* バンド幅 `len = 2K + 1`。
	* 配列インデックスに負数を使わないため、中心バンドの左端を `bias = K` とする。  
		例: 対角線 `k = i - j` のセルは `idx = k + bias` にマップ。
3. **テーブル初期化**
	* 0 行目だけ埋める。バンド外の初期値は `K + 1`。
	* `dp1`, `dp2` のサイズは `len`。両方とも `Arrays.fill(dp?, K + 1)` で埋めておく。
4. **メインループ**（各行 `i=1..sLen`）
	* 行の先頭で `minDist = K + 1` にリセット。
	* 列 `j` はバンド内のみループ: `max(1, i-K)` … `min(tLen, i+K)`。
	* 遷移式
```java
int sub = dp1[idx] + cost;    // cost = (s[i-1]==t[j-1] ? 0 : 1)
     int del = dp1[idx + 1] + 1;   // k-1 → idx+1
     int ins = dp2[idx - 1] + 1;   // k+1 → idx-1
     dp2[idx] = Math.min(sub, Math.min(del, ins));
     minDist = Math.min(minDist, dp2[idx]);
```

* **枝刈り**: `minDist > K` になったらその行以降は計算不要（早期終了）。
* 行末で `dp1` と `dp2` をスワップし、`dp2` を再び `K+1` で埋める。
5. **結果**
	* `dp1[bias + (sLen - tLen)]` が編集距離。
	* もし `> K` なら「距離は K+1 以上」。

#### よくある落とし穴

* **idx のずれ** … `k = i - j` と `idx = k + bias` の整合を常に確認。
* **初期値** … バンド外は常に `K+1`。0 行目・0 列目を部分的に埋め忘れると誤差が出る。
* **K が大きい場合** … 普通の O(|S||T|) DP を使う方が速い場合もある。切替ロジックを用意。

---

### 2️⃣ Wu のアルゴリズム実装ガイド

| 項目 | 内容 |
|---|---|
| 目的 | 正確な編集距離（制約なし）または距離 ≤ K 判定 |
| 時間計算量 | O(N × D) （N = |S|+|T|, D = 編集距離） |
| メモリ | O(N) ― 1 本の `int[] V` のみ |

#### 基本概念

* **対角線 k** … セル (i, j) で `k = i - j`。
* **V[k]** … 編集距離 d までに到達できる「最も右側の x 座標」。  
	（つまり (x, y)=(V[k], V[k]−k) が到達可能な最大 x）
* **Snake** … 文字が一致する限り対角線を滑る操作（コスト 0）。

#### 実装手順（Java）

1. **前処理**
	* `s`, `t` をそのまま使う（長短は気にしなくてよいが、短い方を先にすると早い）。
	* `delta = sLen - tLen` を計算。
2. **V 配列準備**
	* サイズ `2*maxLen + 3` 程度。
	* `bias = maxLen + 1` とし、`k_idx = k + bias` にマップ。
	* `Arrays.fill(V, -1); V[bias] = 0;`
3. **ループ**
```java
for (int d = 0; ; d++) {
       for (int k = -d; k <= d; k += 2) {
           int kIdx = k + bias;
           int x;
           // 3 つの移動のうち「より右側」に到達するものを選択
           if (k == -d || (k != d && V[kIdx - 1] < V[kIdx + 1])) {
               x = V[kIdx + 1];      // ↓（削除）から来る
           } else {
               x = V[kIdx - 1] + 1;  // →（挿入）から来る
           }
           int y = x - k;
           // Snake: 一致する限り斜めに進む
           while (x < sLen && y < tLen && s.charAt(x) == t.charAt(y)) {
               x++; y++;
           }
           V[kIdx] = x;            // 新しい最遠点を保存
           // 終点判定
           if (k == delta && x >= sLen) {
               return d;
           }
       }
   }
```

4. **K‐判定に使う場合**
	* 外側ループの条件を `d ≤ K` にしておき、抜けたら「編集距離 > K」。

#### よくある落とし穴

* **負のインデックス** … 必ず `bias` を足してから配列アクセス。
* **Snake 処理の境界** … `x < sLen && y < tLen` を先に書く。順序逆だと `y` が負の場合に例外。
* **V 配列の再利用** … 1 本の配列を上書きするので、読み取りと書き込みの順序に注意。
* **一致と置換の区別** … Snake は「一致 0 コスト」だけ。文字の不一致は Snake の外で計算済みの 1 コストに含まれる。

---

## 🌟 選択指針

| 状況 | 推奨手法 |
|---|---|
| あらかじめ「距離 ≤ K」と決まっている判定 | Banded DP |
| 距離そのものを求めたい & 差分が小さい（≲64 文字差） | Wu |
| 差分が大きい / K が入力により大幅変動 | 動的に両者を切替える |

---

## 🛠️ 実装とテストのヒント

1. **ユニットテスト**
	* 空文字列、完全一致、1 文字違い、全く異なる、長さが大きく異なる … の 5 パターンは最低限用意。
2. **フェイルセーフ**
	* 許容距離を超えたら即座に `K+1` を返す設計にし、上位ロジックで弾く。
3. **パフォーマンス計測**
	* `System.nanoTime()` で両アルゴリズムを同一データセットで計測し、閾値をチューニング。
4. **可読性**
	* `kIdx(k)` のような小ヘルパーでオフセット処理を隠すとバグが減る。

---

以上が再整理したガイドです。これを参考に実装・最適化・テストを進めてみてください。ご不明点があればいつでもお知らせください。