# LevenshteinDP 利用ガイド

## 概要

LevenshteinDPクラスは、2つの文字列（または文字配列、整数配列）間のレーベンシュタイン距離（編集距離）を計算するためのユーティリティクラスです。
レーベンシュタイン距離とは、一方の文字列を他方に変換するために必要な最小の編集操作（挿入、削除、置換）の回数を表します。

## 特徴

- 複数のデータ型（String、char[]、int[]）に対応した編集距離計算メソッドを提供
- メモリ効率の良い実装（2次元配列ではなく、2つの1次元配列を使用）
- 最大許容距離（k）を指定することで、bandedDPアルゴリズムによる高速化（O(|S|K)の時間計算量）
- 文字列の長さの差が最大許容距離を超える場合の即時判定による最適化
- bandedDPアルゴリズムは、編集距離がk以下の場合、実際の変更はダイアゴナルから最大でもk離れた位置にしか現れないという性質を利用

## 依存関係

このクラスは以下のJava標準ライブラリに依存しています：

- java.lang.Math.abs
- java.lang.Math.min
- java.util.Arrays.setAll

## 主な機能（メソッド一覧）

### 1. 文字列間の編集距離計算メソッド

| メソッド                                           | 戻り値の型 | 説明                                    |
|------------------------------------------------|-------|---------------------------------------|
| computeEditDistance(String s, String t)        | int   | 2つの文字列間の編集距離を計算します                    |
| computeEditDistance(String s, String t, int k) | int   | 2つの文字列間の編集距離を計算します。距離がkを超える場合は-1を返します |

### 2. 文字配列間の編集距離計算メソッド

| メソッド                                           | 戻り値の型 | 説明                                     |
|------------------------------------------------|-------|----------------------------------------|
| computeEditDistance(char[] s, char[] t)        | int   | 2つの文字配列間の編集距離を計算します                    |
| computeEditDistance(char[] s, char[] t, int k) | int   | 2つの文字配列間の編集距離を計算します。距離がkを超える場合は-1を返します |

### 3. 整数配列間の編集距離計算メソッド

| メソッド                                         | 戻り値の型 | 説明                                     |
|----------------------------------------------|-------|----------------------------------------|
| computeEditDistance(int[] s, int[] t)        | int   | 2つの整数配列間の編集距離を計算します                    |
| computeEditDistance(int[] s, int[] t, int k) | int   | 2つの整数配列間の編集距離を計算します。距離がkを超える場合は-1を返します |

## 利用例

```java
// 基本的な編集距離の計算
String s1 = "kitten";
String s2 = "sitting";
int distance = LevenshteinDP.computeEditDistance(s1, s2);
System.out.println("編集距離: " + distance);  // 出力: 編集距離: 3

// 最大許容距離を指定した編集距離の計算
int maxDistance = 2;
int result = LevenshteinDP.computeEditDistance(s1, s2, maxDistance);
System.out.println("結果: " + result);  // 出力: 結果: -1（距離が2を超えるため）

// 文字配列を使用した編集距離の計算
char[] c1 = {'h', 'e', 'l', 'l', 'o'};
char[] c2 = {'h', 'a', 'l', 'l', 'o'};
int charArrayDistance = LevenshteinDP.computeEditDistance(c1, c2);
System.out.println("文字配列の編集距離: " + charArrayDistance);  // 出力: 文字配列の編集距離: 1

// 整数配列を使用した編集距離の計算
int[] a1 = {1, 2, 3, 4, 5};
int[] a2 = {1, 3, 4, 5, 6};
int intArrayDistance = LevenshteinDP.computeEditDistance(a1, a2);
System.out.println("整数配列の編集距離: " + intArrayDistance);  // 出力: 整数配列の編集距離: 2
```

## 注意事項

- 編集距離の計算は、文字列の長さに対して二次計算量（O(n*m)）を持ちます
- 最大許容距離（k）を指定すると、計算が早期終了する可能性があり、パフォーマンスが向上します
- 文字列の長さの差が最大許容距離（k）を超える場合、計算せずに-1を返します
- 最大許容距離を指定したメソッドは、距離がkを超える場合に-1を返します

## パフォーマンス特性

- 基本的な実装の時間計算量: O(n*m)、ここでnとmは2つの入力配列の長さです
- 最大許容距離（k）を指定した場合の時間計算量: O(|S|K)、ここで|S|は短い方の配列の長さ、Kは最大許容距離です
- 空間計算量:
	- 基本的な実装: O(min(n,m))、常に短い方の配列に対してのみメモリを確保します
	- bandedDP実装: O(K)、Kは最大許容距離です
- bandedDPアルゴリズムは、編集距離がk以下の場合に特に効率的で、大きな配列でも高速に計算できます
- すべてのメソッドは、メモリ効率を最適化するために2つの1次元配列のみを使用します

## バージョン情報

| バージョン番号       | 年月日        | 詳細                                                   |
|:--------------|:-----------|:-----------------------------------------------------|
| **バージョン 1.0** | 2025-07-11 | 初期実装                                                 |
| **バージョン 1.1** | 2025-07-21 | すべてのメソッドにメモリ効率の良い実装を適用                               |
| **バージョン 1.2** | 2025-07-22 | すべての最大許容距離（k）指定メソッドにbandedDPアルゴリズム（O(\|S\|K)）を適用し高速化 |

### バージョン管理について

バージョン番号は2桁で管理します：

- 1桁目（メジャーバージョン）: メソッドの追加や機能拡張があった場合に更新
- 2桁目（マイナーバージョン）: 誤字修正、バグ修正、マイクロ高速化などの小さな更新があった場合に更新