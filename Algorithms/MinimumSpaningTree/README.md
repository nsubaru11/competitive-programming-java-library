# 最小全域木 (Minimum Spanning Tree)

## 概要

最小全域木（MST）は、グラフの全ての頂点を含み、辺の重みの合計が最小となる木です。このライブラリでは、最小全域木を求めるための複数のアルゴリズムを提供しています。

## 実装クラス

### Kruskal

- **用途**: 辺の重みを基準にして最小全域木を求めるアルゴリズム
- **特徴**:
	- Union-Find（素集合データ構造）を使用して効率的にサイクル検出
	- 最小全域木と最大全域木の両方に対応
	- 辺をソートして処理するため、疎なグラフに適している
- **時間計算量**: O(|E|log|E|)、ここで|E|は辺の数
- **空間計算量**: O(|V| + |E|)、ここで|V|は頂点の数

### Prim

- **用途**: 頂点の集合を拡張して最小全域木を求めるアルゴリズム
- **特徴**:
	- 優先度付きキューを使用して次に追加する辺を選択
	- 最小全域木と最大全域木の両方に対応
	- 隣接リスト表現を使用
	- 密なグラフに適している
- **時間計算量**: O(|E|log|V|)、ここで|E|は辺の数、|V|は頂点の数
- **空間計算量**: O(|V| + |E|)

### Edmonds

- **用途**: 有向グラフの最小全域木（最小全域有向木）を求めるアルゴリズム
- **特徴**:
	- 実装予定（coming soon）

## 主なメソッド

### Kruskal

| メソッド                                | 説明                        |
|-------------------------------------|---------------------------|
| `Kruskal(int v)`                    | 頂点数vの最小全域木を求めるソルバーを初期化    |
| `Kruskal(int v, boolean isMinimum)` | 頂点数vの最小/最大全域木を求めるソルバーを初期化 |
| `addEdge(int u, int v, long cost)`  | グラフに辺を追加                  |
| `solve()`                           | Kruskal法を実行し、全域木の総コストを計算  |

### Prim

| メソッド                               | 説明                        |
|------------------------------------|---------------------------|
| `Prim(int v)`                      | 頂点数vの最小全域木を求めるソルバーを初期化    |
| `Prim(int v, boolean isMinimum)`   | 頂点数vの最小/最大全域木を求めるソルバーを初期化 |
| `addEdge(int u, int v, long cost)` | グラフに無向辺を追加                |
| `solve()`                          | Prim法を実行し、全域木の総コストを計算     |

## 使用例

    // Kruskalアルゴリズムの使用例
    Kruskal k = new Kruskal(5);
    k.addEdge(0, 1, 3);
    k.addEdge(0, 4, 1);
    k.addEdge(1, 4, 4);
    k.addEdge(2, 3, 2);
    k.addEdge(3, 4, 7);
    k.addEdge(1, 2, 5);
    k.addEdge(2, 4, 6);
    k.addEdge(3, 1, 2);
    long kruskalCost = k.solve();
    System.out.println(kruskalCost);  // 最小全域木のコスト

    // Primアルゴリズムの使用例
    Prim p = new Prim(5);
    p.addEdge(0, 1, 3);
    p.addEdge(0, 4, 1);
    p.addEdge(1, 4, 4);
    p.addEdge(2, 3, 2);
    p.addEdge(3, 4, 7);
    p.addEdge(1, 2, 5);
    p.addEdge(2, 4, 6);
    p.addEdge(3, 1, 2);
    long primCost = p.solve();
    System.out.println(primCost);  // 最小全域木のコスト

## 注意事項

- グラフが連結でない場合、`solve()`メソッドは-1を返します
- Kruskalアルゴリズムでは辺は有向として追加されますが、最小全域木の計算では無向グラフとして扱われます
- Primアルゴリズムでは辺は無向として追加されます